name: 'Blacksmith Cache Checkout'
description: 'Checkout a Git repository using Blacksmith sticky disk for caching. Falls back to standard checkout on non-Blacksmith runners or cache failures.'

inputs:
  repository:
    description: 'Repository name with owner (e.g., owner/repo)'
    default: ${{ github.repository }}
  ref:
    description: 'Branch, tag, or SHA to checkout'
    required: false
  token:
    description: 'GitHub token for HTTPS auth'
    default: ${{ github.token }}
  ssh-key:
    description: 'SSH private key for SSH auth'
    required: false
  fetch-depth:
    description: 'Number of commits to fetch (0 for full history)'
    default: '1'
  path:
    description: 'Relative path to checkout'
    required: false
  refresh-cache:
    description: 'Clear cache and re-clone fresh (use to fix poisoned cache)'
    default: 'false'
  clean:
    description: 'Remove untracked files before checkout'
    default: 'true'

outputs:
  ref:
    description: 'Branch or SHA checked out'
    value: ${{ steps.checkout.outputs.ref }}
  commit:
    description: 'Commit SHA checked out'
    value: ${{ steps.checkout.outputs.commit }}

runs:
  using: 'composite'
  steps:
    - name: Detect Blacksmith runner
      id: detect
      shell: bash
      run: |
        if [ -n "$BLACKSMITH_VM_ID" ] && [ "$RUNNER_OS" = "Linux" ]; then
          echo "is-blacksmith=true" >> $GITHUB_OUTPUT
        else
          echo "is-blacksmith=false" >> $GITHUB_OUTPUT
        fi

    - name: Mount sticky disk
      id: stickydisk
      if: steps.detect.outputs.is-blacksmith == 'true'
      continue-on-error: true
      uses: useblacksmith/stickydisk@v1
      with:
        key: ${{ format('v1-{0}-git-mirror', inputs.repository) }}
        path: /tmp/git-mirror

    - name: Checkout
      id: checkout
      shell: bash
      env:
        REPO: ${{ inputs.repository }}
        REF: ${{ inputs.ref || github.ref }}
        TOKEN: ${{ inputs.token }}
        SSH_KEY: ${{ inputs.ssh-key }}
        FETCH_DEPTH: ${{ inputs.fetch-depth }}
        WORKSPACE: ${{ inputs.path && format('{0}/{1}', github.workspace, inputs.path) || github.workspace }}
        MIRROR_PATH: /tmp/git-mirror
        REFRESH_CACHE: ${{ inputs.refresh-cache }}
        USE_MIRROR: ${{ steps.detect.outputs.is-blacksmith == 'true' && steps.stickydisk.outcome == 'success' }}
        CLEAN: ${{ inputs.clean }}
      run: |
        set -euo pipefail

        # === Debug helper ===
        debug_mirror_stats() {
          local label="$1"
          if [ "$RUNNER_DEBUG" = "1" ] && [ -d "$MIRROR_PATH/objects" ]; then
            echo "::debug::Mirror size ($label): $(du -sh "$MIRROR_PATH" 2>/dev/null | cut -f1 || echo "unknown")"
            echo "::debug::Mirror objects ($label): $(git -C "$MIRROR_PATH" count-objects -v | grep in-pack | awk '{print $2}')"
          fi
        }

        # === Debug: show mirror stats at start ===
        [ "$USE_MIRROR" = "true" ] && debug_mirror_stats "before"

        # === Refresh cache mode ===
        if [ "$REFRESH_CACHE" = "true" ] && [ "$USE_MIRROR" = "true" ]; then
          echo "ðŸ”„ Refresh mode: clearing mirror cache"
          rm -rf "$MIRROR_PATH"/* "$MIRROR_PATH"/.[!.]* 2>/dev/null || true
        fi

        # === Setup auth (from actions/checkout) ===
        if [ -n "$SSH_KEY" ]; then
          # SSH auth
          SSH_KEY_PATH="$RUNNER_TEMP/ssh_key_$$"
          echo "$SSH_KEY" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"

          KNOWN_HOSTS_PATH="$RUNNER_TEMP/known_hosts_$$"
          [ -f ~/.ssh/known_hosts ] && cat ~/.ssh/known_hosts > "$KNOWN_HOSTS_PATH"
          echo "github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=" >> "$KNOWN_HOSTS_PATH"

          export GIT_SSH_COMMAND="ssh -i '$SSH_KEY_PATH' -o StrictHostKeyChecking=yes -o UserKnownHostsFile='$KNOWN_HOSTS_PATH'"
          REPO_URL="git@github.com:${REPO}.git"
        else
          # HTTPS auth with token
          REPO_URL="https://github.com/${REPO}"
          AUTH_HEADER="AUTHORIZATION: basic $(echo -n "x-access-token:${TOKEN}" | base64)"
        fi

        # === Helper function for git with auth ===
        git_auth() {
          if [ -n "${AUTH_HEADER:-}" ]; then
            git -c "http.https://github.com/.extraheader=$AUTH_HEADER" "$@"
          else
            git "$@"
          fi
        }

        # === Mask credentials in logs ===
        if [ -n "${TOKEN:-}" ]; then
          echo "::add-mask::$TOKEN"
        fi

        # === Ensure mirror exists (only if USE_MIRROR) ===
        # Mirror is only initialized/updated in refresh mode or when empty
        # Normal checkouts use mirror as-is for speed (stale objects handled by --reference-if-able)
        if [ "$USE_MIRROR" = "true" ]; then
          if [ ! -d "$MIRROR_PATH/objects" ] || [ "$REFRESH_CACHE" = "true" ]; then
            if [ "$REFRESH_CACHE" = "true" ] && [ -d "$MIRROR_PATH/objects" ]; then
              echo "ðŸ”„ Refresh mode: updating mirror cache"
              if ! git_auth -C "$MIRROR_PATH" fetch --all --prune --prune-tags 2>/dev/null; then
                echo "âš ï¸ Mirror fetch failed, re-cloning from scratch"
                rm -rf "$MIRROR_PATH"/* "$MIRROR_PATH"/.[!.]* 2>/dev/null || true
                git_auth clone --mirror "$REPO_URL" "$MIRROR_PATH" || true
              fi
            else
              echo "ðŸ“¦ Initializing mirror cache"
              # Full mirror (no --filter) so blobs are available for --reference clones
              git_auth clone --mirror "$REPO_URL" "$MIRROR_PATH" || true
            fi
          else
            echo "ðŸ“¦ Using existing mirror cache"
          fi
          debug_mirror_stats "after"
        fi

        # === Clone workspace ===
        mkdir -p "$WORKSPACE"
        cd "$WORKSPACE"

        # Clean workspace if requested and .git exists
        if [ -d ".git" ]; then
          if [ "$CLEAN" = "true" ]; then
            echo "ðŸ§¹ Cleaning workspace"
            git clean -ffdx 2>/dev/null || true
            git reset --hard 2>/dev/null || true
          fi
          rm -rf .git
        fi

        DEPTH_ARG=""
        [ "$FETCH_DEPTH" != "0" ] && DEPTH_ARG="--depth $FETCH_DEPTH"

        # Try with reference first, fallback to plain clone
        CLONE_SUCCESS=false

        if [ "$USE_MIRROR" = "true" ] && [ -d "$MIRROR_PATH/objects" ]; then
          echo "ðŸš€ Cloning with reference (--reference-if-able --dissociate)"
          # --reference-if-able: warns but continues if reference unavailable
          # --dissociate: copies objects locally, removes alternates dependency
          if git_auth clone $DEPTH_ARG --reference-if-able "$MIRROR_PATH" --dissociate "$REPO_URL" .; then
            CLONE_SUCCESS=true
            echo "âœ… Clone with reference succeeded"
          else
            echo "âš ï¸ Clone with reference failed, falling back to plain clone"
            rm -rf .git 2>/dev/null || true
          fi
        fi

        if [ "$CLONE_SUCCESS" = "false" ]; then
          echo "ðŸ“¥ Cloning without reference"
          git_auth clone $DEPTH_ARG "$REPO_URL" .
        fi

        # === Checkout specific ref ===
        if [ -n "$REF" ]; then
          # Determine ref type
          SHA_PATTERN='^[0-9a-fA-F]{40}$'

          if [[ "$REF" =~ $SHA_PATTERN ]]; then
            REF_TYPE="sha"
          elif [[ "$REF" == refs/heads/* ]]; then
            REF_TYPE="branch"
            BRANCH_NAME="${REF#refs/heads/}"
          elif [[ "$REF" == refs/pull/*/head ]] || [[ "$REF" == refs/pull/*/merge ]]; then
            REF_TYPE="pr"
          elif [[ "$REF" == refs/tags/* ]]; then
            REF_TYPE="tag"
          elif [[ "$REF" == refs/* ]]; then
            REF_TYPE="ref"
          else
            REF_TYPE="unqualified"
          fi

          echo "ðŸ”€ Checking out $REF (type: $REF_TYPE)"

          case "$REF_TYPE" in
            sha)
              # Fetch specific commit - may need to deepen for shallow clones
              if [ "$FETCH_DEPTH" != "0" ]; then
                git_auth fetch --depth=1 origin "$REF" 2>/dev/null || git_auth fetch --unshallow origin 2>/dev/null || git_auth fetch origin
              else
                git_auth fetch origin
              fi
              git checkout "$REF" --quiet
              ;;
            branch)
              git_auth fetch origin "$REF" $DEPTH_ARG
              git checkout -B "$BRANCH_NAME" FETCH_HEAD --quiet
              ;;
            pr)
              # PR refs need explicit refspec
              git_auth fetch origin "+$REF:refs/remotes/origin/${REF#refs/}" $DEPTH_ARG
              git checkout FETCH_HEAD --quiet
              ;;
            tag)
              git_auth fetch origin "$REF:$REF" --no-tags $DEPTH_ARG
              git checkout "$REF" --quiet
              ;;
            ref)
              git_auth fetch origin "+$REF:$REF" $DEPTH_ARG
              git checkout FETCH_HEAD --quiet
              ;;
            *)
              # Unqualified - let git figure it out
              git_auth fetch origin "$REF" $DEPTH_ARG 2>/dev/null || git_auth fetch origin "refs/heads/$REF" $DEPTH_ARG 2>/dev/null || git_auth fetch origin "refs/tags/$REF" $DEPTH_ARG
              git checkout "$REF" --quiet 2>/dev/null || git checkout FETCH_HEAD --quiet
              ;;
          esac
        fi

        # === Persist credentials ===
        echo "ðŸ”‘ Persisting credentials"
        if [ -n "$SSH_KEY" ]; then
          # For SSH, configure insteadOf to use SSH for github.com
          git config --local url."git@github.com:".insteadOf "https://github.com/"
        else
          # For HTTPS, store the extraheader
          git config --local "http.https://github.com/.extraheader" "$AUTH_HEADER"
        fi

        # === Output ===
        echo "ref=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse HEAD)" >> $GITHUB_OUTPUT
        echo "commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

        # === Cleanup temp SSH files ===
        rm -f "${SSH_KEY_PATH:-}" "${KNOWN_HOSTS_PATH:-}" 2>/dev/null || true
