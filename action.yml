name: 'Blacksmith Cache Checkout'
description: 'Checkout a Git repository using Blacksmith sticky disk for caching. Falls back to standard checkout on non-Blacksmith runners or cache failures.'

inputs:
  repository:
    description: 'Repository name with owner (e.g., owner/repo)'
    default: ${{ github.repository }}
  ref:
    description: 'Branch, tag, or SHA to checkout'
    required: false
  token:
    description: 'GitHub token for HTTPS auth'
    default: ${{ github.token }}
  ssh-key:
    description: 'SSH private key for SSH auth'
    required: false
  fetch-depth:
    description: 'Number of commits to fetch (0 for full history)'
    default: '1'
  path:
    description: 'Relative path to checkout'
    required: false
  refresh-cache:
    description: 'Clear cache and re-clone fresh (use to fix poisoned cache)'
    default: 'false'

outputs:
  ref:
    description: 'Branch or SHA checked out'
    value: ${{ steps.checkout.outputs.ref }}
  commit:
    description: 'Commit SHA checked out'
    value: ${{ steps.checkout.outputs.commit }}

runs:
  using: 'composite'
  steps:
    - name: Detect Blacksmith runner
      id: detect
      shell: bash
      run: |
        if [ -n "$BLACKSMITH_VM_ID" ] && [ "$RUNNER_OS" = "Linux" ]; then
          echo "is-blacksmith=true" >> $GITHUB_OUTPUT
        else
          echo "is-blacksmith=false" >> $GITHUB_OUTPUT
        fi

    - name: Mount sticky disk
      id: stickydisk
      if: steps.detect.outputs.is-blacksmith == 'true'
      continue-on-error: true
      uses: useblacksmith/stickydisk@v1
      with:
        # Version prefix (v1) allows cache invalidation on breaking changes
        # Uses inputs.repository (not github.repository) to support cross-repo checkouts
        key: ${{ format('v1-{0}-git-mirror', inputs.repository) }}
        path: /tmp/git-mirror

    - name: Checkout
      id: checkout
      shell: bash
      env:
        REPO: ${{ inputs.repository }}
        REF: ${{ inputs.ref || github.ref }}
        TOKEN: ${{ inputs.token }}
        SSH_KEY: ${{ inputs.ssh-key }}
        FETCH_DEPTH: ${{ inputs.fetch-depth }}
        WORKSPACE: ${{ inputs.path && format('{0}/{1}', github.workspace, inputs.path) || github.workspace }}
        MIRROR_PATH: /tmp/git-mirror
        REFRESH_CACHE: ${{ inputs.refresh-cache }}
        USE_MIRROR: ${{ steps.detect.outputs.is-blacksmith == 'true' && steps.stickydisk.outcome == 'success' }}
      run: |
        set -euo pipefail

        # === Refresh cache mode ===
        if [ "$REFRESH_CACHE" = "true" ] && [ "$USE_MIRROR" = "true" ]; then
          echo "ðŸ”„ Refresh mode: clearing mirror cache"
          rm -rf "$MIRROR_PATH"/* "$MIRROR_PATH"/.[!.]* 2>/dev/null || true
        fi

        # === Setup auth (from actions/checkout) ===
        if [ -n "$SSH_KEY" ]; then
          # SSH auth
          SSH_KEY_PATH="$RUNNER_TEMP/ssh_key_$$"
          echo "$SSH_KEY" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"

          KNOWN_HOSTS_PATH="$RUNNER_TEMP/known_hosts_$$"
          [ -f ~/.ssh/known_hosts ] && cat ~/.ssh/known_hosts > "$KNOWN_HOSTS_PATH"
          echo "github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=" >> "$KNOWN_HOSTS_PATH"

          export GIT_SSH_COMMAND="ssh -i '$SSH_KEY_PATH' -o StrictHostKeyChecking=yes -o UserKnownHostsFile='$KNOWN_HOSTS_PATH'"
          REPO_URL="git@github.com:${REPO}.git"
        else
          # HTTPS auth with token
          REPO_URL="https://github.com/${REPO}"
          AUTH_HEADER="AUTHORIZATION: basic $(echo -n "x-access-token:${TOKEN}" | base64)"
        fi

        # === Helper function for git with auth ===
        git_auth() {
          if [ -n "${AUTH_HEADER:-}" ]; then
            git -c "http.https://github.com/.extraheader=$AUTH_HEADER" "$@"
          else
            git "$@"
          fi
        }

        # === Mask credentials in logs ===
        if [ -n "${TOKEN:-}" ]; then
          echo "::add-mask::$TOKEN"
        fi

        # === Ensure mirror exists (only if USE_MIRROR) ===
        # Mirror is only initialized/updated in refresh mode or when empty
        # Normal checkouts use mirror as-is for speed (stale objects handled by --reference-if-able)
        if [ "$USE_MIRROR" = "true" ]; then
          if [ ! -d "$MIRROR_PATH/objects" ] || [ "$REFRESH_CACHE" = "true" ]; then
            if [ "$REFRESH_CACHE" = "true" ] && [ -d "$MIRROR_PATH/objects" ]; then
              echo "ðŸ”„ Refresh mode: updating mirror cache"
              if ! git_auth -C "$MIRROR_PATH" fetch --all --prune --prune-tags 2>/dev/null; then
                echo "âš ï¸ Mirror fetch failed, re-cloning from scratch"
                rm -rf "$MIRROR_PATH"/* "$MIRROR_PATH"/.[!.]* 2>/dev/null || true
                git_auth clone --mirror "$REPO_URL" "$MIRROR_PATH" || true
              fi
            else
              echo "ðŸ“¦ Initializing mirror cache"
              # Full mirror (no --filter) so blobs are available for --reference clones
              git_auth clone --mirror "$REPO_URL" "$MIRROR_PATH" || true
            fi
          else
            echo "ðŸ“¦ Using existing mirror cache"
          fi
        fi

        # === Clone workspace ===
        mkdir -p "$WORKSPACE"
        cd "$WORKSPACE"

        # Clean workspace if it has existing .git (from previous failed run)
        if [ -d ".git" ]; then
          echo "âš ï¸ Cleaning existing .git directory"
          rm -rf .git
        fi

        DEPTH_ARG=""
        [ "$FETCH_DEPTH" != "0" ] && DEPTH_ARG="--depth $FETCH_DEPTH"

        # Try with reference first, fallback to plain clone
        CLONE_SUCCESS=false

        if [ "$USE_MIRROR" = "true" ] && [ -d "$MIRROR_PATH/objects" ]; then
          echo "ðŸš€ Cloning with reference (--reference-if-able --dissociate)"
          # --reference-if-able: warns but continues if reference unavailable
          # --dissociate: copies objects locally, removes alternates dependency
          if git_auth clone $DEPTH_ARG --reference-if-able "$MIRROR_PATH" --dissociate "$REPO_URL" .; then
            CLONE_SUCCESS=true
            echo "âœ… Clone with reference succeeded"
          else
            echo "âš ï¸ Clone with reference failed, falling back to plain clone"
            rm -rf .git 2>/dev/null || true
          fi
        fi

        if [ "$CLONE_SUCCESS" = "false" ]; then
          echo "ðŸ“¥ Cloning without reference"
          git_auth clone $DEPTH_ARG "$REPO_URL" .
        fi

        # === Checkout specific ref ===
        if [ -n "$REF" ]; then
          CURRENT_REF="refs/heads/$(git symbolic-ref --short HEAD 2>/dev/null || true)"
          if [ "$REF" != "$CURRENT_REF" ]; then
            echo "ðŸ”€ Checking out $REF"
            git_auth fetch origin "$REF" $DEPTH_ARG || true
            git checkout FETCH_HEAD --quiet 2>/dev/null || git checkout "$REF" --quiet
          fi
        fi

        # === Output ===
        echo "ref=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse HEAD)" >> $GITHUB_OUTPUT
        echo "commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

        # === Cleanup SSH ===
        rm -f "${SSH_KEY_PATH:-}" "${KNOWN_HOSTS_PATH:-}" 2>/dev/null || true
