name: 'Blacksmith Cache Checkout'
description: 'Checkout a Git repository using Blacksmith sticky disk for caching. Falls back to standard checkout on non-Blacksmith runners or cache failures.'

inputs:
  repository:
    description: 'Repository name with owner (e.g., owner/repo)'
    default: ${{ github.repository }}
  ref:
    description: 'Branch, tag, or SHA to checkout'
    required: false
  token:
    description: 'GitHub token for HTTPS auth'
    default: ${{ github.token }}
  ssh-key:
    description: 'SSH private key for SSH auth'
    required: false
  fetch-depth:
    description: 'Number of commits to fetch (0 for full history)'
    default: '1'
  path:
    description: 'Relative path to checkout'
    required: false
  refresh-cache:
    description: 'Clear cache and re-clone fresh (use to fix poisoned cache)'
    default: 'false'
  clean:
    description: 'Remove untracked files before checkout'
    default: 'true'

outputs:
  ref:
    description: 'Branch or SHA checked out'
    value: ${{ steps.checkout.outputs.ref }}
  commit:
    description: 'Commit SHA checked out'
    value: ${{ steps.checkout.outputs.commit }}

runs:
  using: 'composite'
  steps:
    - name: Detect Blacksmith runner
      id: detect
      shell: bash
      run: |
        if [ -n "$BLACKSMITH_VM_ID" ] && [ "$RUNNER_OS" = "Linux" ]; then
          echo "is-blacksmith=true" >> $GITHUB_OUTPUT
        else
          echo "is-blacksmith=false" >> $GITHUB_OUTPUT
        fi

    - name: Mount sticky disk
      id: stickydisk
      if: steps.detect.outputs.is-blacksmith == 'true'
      continue-on-error: true
      uses: useblacksmith/stickydisk@v1
      with:
        key: ${{ format('v1-{0}-git-mirror', inputs.repository) }}
        path: /tmp/git-mirror

    - name: Checkout
      id: checkout
      shell: bash
      env:
        REPO: ${{ inputs.repository }}
        REF: ${{ inputs.ref || github.ref }}
        TOKEN: ${{ inputs.token }}
        SSH_KEY: ${{ inputs.ssh-key }}
        FETCH_DEPTH: ${{ inputs.fetch-depth }}
        WORKSPACE: ${{ inputs.path && format('{0}/{1}', github.workspace, inputs.path) || github.workspace }}
        MIRROR_PATH: /tmp/git-mirror
        REFRESH_CACHE: ${{ inputs.refresh-cache }}
        USE_MIRROR: ${{ steps.detect.outputs.is-blacksmith == 'true' && steps.stickydisk.outcome == 'success' }}
        CLEAN: ${{ inputs.clean }}
      run: |
        set -euo pipefail

        # === Debug helper ===
        debug_mirror_stats() {
          local label="$1"
          if [ "${RUNNER_DEBUG:-}" = "1" ] && [ -d "$MIRROR_PATH/objects" ]; then
            echo "::debug::Mirror size ($label): $(du -sh "$MIRROR_PATH" 2>/dev/null | cut -f1 || echo "unknown")"
            echo "::debug::Mirror objects ($label): $(git -C "$MIRROR_PATH" count-objects -v | grep in-pack | awk '{print $2}')"
          fi
        }

        # === Debug: show mirror stats at start ===
        [ "$USE_MIRROR" = "true" ] && debug_mirror_stats "before"

        # === Setup auth (from actions/checkout) ===
        if [ -n "$SSH_KEY" ]; then
          # SSH auth
          SSH_KEY_PATH="$RUNNER_TEMP/ssh_key_$$"
          echo "$SSH_KEY" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"

          KNOWN_HOSTS_PATH="$RUNNER_TEMP/known_hosts_$$"
          [ -f ~/.ssh/known_hosts ] && cat ~/.ssh/known_hosts > "$KNOWN_HOSTS_PATH"
          echo "github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=" >> "$KNOWN_HOSTS_PATH"

          export GIT_SSH_COMMAND="ssh -i '$SSH_KEY_PATH' -o StrictHostKeyChecking=yes -o UserKnownHostsFile='$KNOWN_HOSTS_PATH'"
          REPO_URL="git@github.com:${REPO}.git"
        else
          # HTTPS auth with token
          REPO_URL="https://github.com/${REPO}"
          AUTH_HEADER="AUTHORIZATION: basic $(echo -n "x-access-token:${TOKEN}" | base64)"
        fi

        # === Helper function for git with auth ===
        git_auth() {
          if [ -n "${AUTH_HEADER:-}" ]; then
            git -c "http.https://github.com/.extraheader=$AUTH_HEADER" "$@"
          else
            git "$@"
          fi
        }

        # === Mask credentials in logs ===
        if [ -n "${TOKEN:-}" ]; then
          echo "::add-mask::$TOKEN"
        fi

        # === Ensure mirror exists (only if USE_MIRROR) ===
        # Mirror is only initialized/updated in refresh mode or when empty
        # Normal checkouts use mirror as-is for speed (stale objects handled by --reference-if-able)
        if [ "$USE_MIRROR" = "true" ]; then
          if [ "$REFRESH_CACHE" = "true" ] || [ ! -d "$MIRROR_PATH/objects" ]; then
            echo "ðŸ“¦ Initializing mirror cache"
            rm -rf "$MIRROR_PATH"/* "$MIRROR_PATH"/.[!.]* 2>/dev/null || true
            git_auth clone --mirror "$REPO_URL" "$MIRROR_PATH" || true
          else
            echo "ðŸ“¦ Using existing mirror cache"
          fi
          debug_mirror_stats "after"
        fi

        # === Setup workspace ===
        mkdir -p "$WORKSPACE"
        cd "$WORKSPACE"

        # Clean workspace if requested and .git exists
        if [ -d ".git" ]; then
          if [ "$CLEAN" = "true" ]; then
            echo "ðŸ§¹ Cleaning workspace"
            git clean -ffdx 2>/dev/null || true
            git reset --hard 2>/dev/null || true
          fi
          rm -rf .git
        fi

        DEPTH_ARG=""
        [ "$FETCH_DEPTH" != "0" ] && DEPTH_ARG="--depth $FETCH_DEPTH"

        CHECKOUT_TOTAL_START=$(date +%s)
        FETCH_METHOD="plain"

        # === Build refspec based on REF type ===
        SHA_PATTERN='^[0-9a-fA-F]{40}$'
        if [ -z "$REF" ]; then
          # No ref specified - determine and fetch default branch only
          DEFAULT_BRANCH=$(git ls-remote --symref origin HEAD 2>/dev/null | grep "ref:" | sed 's/.*refs\/heads\/\([^[:space:]]*\).*/\1/' || echo "main")
          REFSPEC="+refs/heads/$DEFAULT_BRANCH:refs/remotes/origin/$DEFAULT_BRANCH"
          CHECKOUT_REF="-B $DEFAULT_BRANCH refs/remotes/origin/$DEFAULT_BRANCH"
        elif [[ "$REF" =~ $SHA_PATTERN ]]; then
          # SHA - fetch it directly
          REFSPEC="$REF"
          CHECKOUT_REF="$REF"
        elif [[ "$REF" == refs/heads/* ]]; then
          # Branch
          BRANCH_NAME="${REF#refs/heads/}"
          REFSPEC="+$REF:refs/remotes/origin/$BRANCH_NAME"
          CHECKOUT_REF="-B $BRANCH_NAME refs/remotes/origin/$BRANCH_NAME"
        elif [[ "$REF" == refs/pull/*/head ]] || [[ "$REF" == refs/pull/*/merge ]]; then
          # PR ref
          REFSPEC="+$REF:refs/remotes/origin/${REF#refs/}"
          CHECKOUT_REF="FETCH_HEAD"
        elif [[ "$REF" == refs/tags/* ]]; then
          # Tag
          REFSPEC="+$REF:$REF"
          CHECKOUT_REF="$REF"
        elif [[ "$REF" == refs/* ]]; then
          # Other ref
          REFSPEC="+$REF:$REF"
          CHECKOUT_REF="FETCH_HEAD"
        else
          # Unqualified - assume branch
          REFSPEC="+refs/heads/$REF:refs/remotes/origin/$REF"
          CHECKOUT_REF="-B $REF refs/remotes/origin/$REF"
        fi

        # === Init ===
        INIT_START=$(date +%s)
        echo "ðŸš€ Initializing repository"
        git init --quiet
        git remote add origin "$REPO_URL"
        INIT_END=$(date +%s)
        echo "Init completed in $((INIT_END - INIT_START))s"

        # === Fetch ===
        FETCH_START=$(date +%s)
        # --no-tags: don't fetch tags unless explicitly requested
        # --no-recurse-submodules: skip submodules
        # protocol.version=2: more efficient negotiation
        FETCH_ARGS="--no-tags --no-recurse-submodules --progress $DEPTH_ARG"

        # If mirror available, copy objects locally first (faster than network fetch)
        if [ "$USE_MIRROR" = "true" ] && [ -d "$MIRROR_PATH/objects" ]; then
          FETCH_METHOD="cached"
          echo "ðŸ“¦ Copying objects from mirror cache"
          COPY_START=$(date +%s)
          # Copy objects (pack files contain most data)
          cp -r "$MIRROR_PATH/objects/"* .git/objects/ 2>/dev/null || true
          # Copy packed-refs if exists
          [ -f "$MIRROR_PATH/packed-refs" ] && cp "$MIRROR_PATH/packed-refs" .git/ 2>/dev/null || true
          COPY_END=$(date +%s)
          echo "Copy completed in $((COPY_END - COPY_START))s"
        else
          FETCH_METHOD="plain"
        fi

        echo "ðŸ“¥ Fetching ${REF:-${DEFAULT_BRANCH:-default}} from origin"
        if ! git_auth -c protocol.version=2 fetch origin $FETCH_ARGS --prune $REFSPEC; then
          echo "âš ï¸ Fetch failed"
          exit 1
        fi
        FETCH_END=$(date +%s)
        echo "Fetch completed in $((FETCH_END - FETCH_START))s (method: $FETCH_METHOD)"

        # === Checkout ===
        CHECKOUT_START=$(date +%s)
        echo "ðŸ”€ Checking out ${REF:-${DEFAULT_BRANCH:-default}}"
        git checkout --progress --force $CHECKOUT_REF
        CHECKOUT_END=$(date +%s)
        echo "Checkout completed in $((CHECKOUT_END - CHECKOUT_START))s"
        echo "::notice::Checkout completed in $((CHECKOUT_END - CHECKOUT_TOTAL_START))s (method: $FETCH_METHOD)"

        # === Persist credentials ===
        echo "ðŸ”‘ Persisting credentials"
        if [ -n "$SSH_KEY" ]; then
          # For SSH, configure insteadOf to use SSH for github.com
          git config --local url."git@github.com:".insteadOf "https://github.com/"
        else
          # For HTTPS, store the extraheader
          git config --local "http.https://github.com/.extraheader" "$AUTH_HEADER"
        fi

        # === Output ===
        echo "ref=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse HEAD)" >> $GITHUB_OUTPUT
        echo "commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

        # === Cleanup temp SSH files ===
        rm -f "${SSH_KEY_PATH:-}" "${KNOWN_HOSTS_PATH:-}" 2>/dev/null || true
